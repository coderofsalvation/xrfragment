<?php
/**
 */

namespace xrfragment;

use \php\_Boot\HxAnon;
use \php\Boot;
use \php\_Boot\HxString;

/**
 * # Spec
 *
 * > version 1.0.0 [![Actions Status](https://github.com/coderofsalvation/xrfragment/workflows/test/badge.svg)](https://github.com/coderofsalvation/xrfragment/actions) generated by `make doc` @ $(date +"%Y-%m-%dT%H:%M:%S%z")
 *
 * ### XR Fragment URI Grammar
 *
 * ```
 *     reserved    = gen-delims / sub-delims
 *     gen-delims  = "#" / "&"
 *     sub-delims  = "," /  "="
 * ```
 *
 * > Example: `://foo.com/my3d.asset#pos=1,0,0&prio=-5&t=0,100|100,200`
 *
 * | Explanation | |
 * |-|-|
 * | `pos=1,2,3` | vector/coordinate argument e.g. |
 * | `pos=1,2,3&rot=0,90,0&q=.foo` | combinators |
 *
 * In case your programming language has no parser ([check here](https://github.com/coderofsalvation/xrfragment/tree/main/dist)) you can [crosscompile it](https://github.com/coderofsalvation/xrfragment/blob/main/build.hxml), or roll your own `Parser.parse(k,v,store)` using the spec:
 *
 */
class URI {
	/**
	 * @param string $url
	 * @param int $filter
	 * 
	 * @return mixed
	 */
	public static function parse ($url, $filter) {
		#src/xrfragment/URI.hx:37: characters 7-50
		$store = new HxAnon();
		#src/xrfragment/URI.hx:38: characters 7-63
		if (($url === null) || (HxString::indexOf($url, "#") === -1)) {
			#src/xrfragment/URI.hx:38: characters 51-63
			return $store;
		}
		#src/xrfragment/URI.hx:39: characters 7-54
		$fragment = HxString::split($url, "#");
		#src/xrfragment/URI.hx:40: characters 7-62
		$splitArray = HxString::split(($fragment->arr[1] ?? null), "&");
		#src/xrfragment/URI.hx:41: characters 19-23
		$_g = 0;
		#src/xrfragment/URI.hx:41: characters 23-40
		$_g1 = $splitArray->length;
		#src/xrfragment/URI.hx:41: lines 41-51
		while ($_g < $_g1) {
			#src/xrfragment/URI.hx:41: characters 19-40
			$i = $_g++;
			#src/xrfragment/URI.hx:43: characters 9-53
			$splitByEqual = HxString::split(($splitArray->arr[$i] ?? null), "=");
			#src/xrfragment/URI.hx:44: characters 9-33
			$regexPlus = new \EReg("\\+", "g");
			#src/xrfragment/URI.hx:45: characters 9-42
			$key = ($splitByEqual->arr[0] ?? null);
			#src/xrfragment/URI.hx:46: characters 5-27
			$value = "";
			#src/xrfragment/URI.hx:47: lines 47-49
			if ($splitByEqual->length > 1) {
				#src/xrfragment/URI.hx:48: characters 19-84
				$value = \urldecode($regexPlus->split(($splitByEqual->arr[1] ?? null))->join(" "));
			}
			#src/xrfragment/URI.hx:50: characters 5-49
			$ok = Parser::parse($key, $value, $store);
		}
		#src/xrfragment/URI.hx:52: lines 52-59
		if (($filter !== null) && ($filter !== 0)) {
			#src/xrfragment/URI.hx:53: lines 53-58
			$_g = 0;
			$_g1 = \Reflect::fields($store);
			while ($_g < $_g1->length) {
				#src/xrfragment/URI.hx:53: characters 14-17
				$key = ($_g1->arr[$_g] ?? null);
				#src/xrfragment/URI.hx:53: lines 53-58
				++$_g;
				#src/xrfragment/URI.hx:54: characters 13-42
				$xrf = \Reflect::field($store, $key);
				#src/xrfragment/URI.hx:55: lines 55-57
				if (!$xrf->is($filter)) {
					#src/xrfragment/URI.hx:56: characters 8-25
					\Reflect::deleteField($store, $key);
				}
			}
		}
		#src/xrfragment/URI.hx:60: characters 7-19
		return $store;
	}
}

Boot::registerClass(URI::class, 'xrfragment.URI');
